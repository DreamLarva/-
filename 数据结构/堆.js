"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaxHeap = exports.MinHeap = void 0;
const __1 = require("./\u5806\u5316");
class Heap {
    data = [];
    constructor(arr) {
        this.data = [...arr];
        // 初始化 堆化
        this.heapifyWithSiftDown();
    }
    /**
     * 堆的大小
     * */
    get size() {
        return this.data.length;
    }
    heapifyWithSiftDown() {
        const A = this.data;
        // 初始选择最接近叶子的一个父结点
        for (let i = Math.floor((A.length - 1) / 2); i >= 0; i--) {
            this.siftDown(A, i);
        }
        return A;
    }
    /**
     * 插入
     * 在堆的尾部添加一个新的元素，然后使用 shiftUp 来修复
     * */
    insert(value) {
        this.data.push(value);
        this.siftUp(this.data, this.size - 1);
    }
    /**
     * 移除并返回最大值（最大堆）或者最小值（最小堆）
     * 为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，
     * 然后使用 shiftDown 方法来修复堆
     * */
    remove() {
        const result = this.data.shift();
        this.heapifyWithSiftDown();
        return result;
    }
    /**
     * 移除并返回堆末尾的数据
     * */
    poll() {
        return this.data.pop();
    }
    /**
     * 移除堆中任意节点
     * 当它与子节点比较位置不时无序时使用 shiftDown()，如果与父节点比较发现无序则使用 shiftUp()
     * */
    removeAtIndex() { }
    /**
     * 将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点
     *
     * */
    replace() { }
}
/**
 * 最小堆(小顶堆)
 * */
class MinHeap extends Heap {
    constructor(arr) {
        super(arr);
    }
    siftUp(A, k) {
        while (k != 0) {
            // 找到父节点
            const father = Math.floor((k - 1) / 2);
            // 如果父节点 > 新加入的节点 符合 堆 结束 该轮
            if (A[k] > A[father]) {
                break;
            }
            // 反之 那么 交换两个节点
            [A[k], A[father]] = [A[father], A[k]];
            // 现在 现在新加入的节点 现在在 原来的父节点上
            k = father;
        }
    }
    siftDown(A, k) {
        while (k * 2 + 1 < A.length) {
            let son = k * 2 + 1;
            // 与其两个儿子中较小的一个比较
            if (k * 2 + 2 < A.length && A[son] > A[k * 2 + 2]) {
                son = k * 2 + 2;
            }
            // 若大于儿子，则与儿子交换。
            if (A[son] > A[k]) {
                break;
            }
            [A[son], A[k]] = [A[k], A[son]];
            // 交换后再与新的儿子比较并交换，直至没有儿子。
            k = son;
        }
    }
}
exports.MinHeap = MinHeap;
/**
 * 最大堆(大顶堆)
 * */
class MaxHeap extends Heap {
    constructor(arr) {
        super(arr);
    }
    siftUp(A, k) {
        while (k != 0) {
            // 找到父节点
            const father = Math.floor((k - 1) / 2);
            // 如果父节点 > 新加入的节点 符合 堆 结束 该轮
            if (A[k] < A[father]) {
                break;
            }
            // 反之 那么 交换两个节点
            [A[k], A[father]] = [A[father], A[k]];
            // 现在 现在新加入的节点 现在在 原来的父节点上
            k = father;
        }
    }
    siftDown(A, k) {
        while (k * 2 + 1 < A.length) {
            let son = k * 2 + 1;
            if (k * 2 + 2 < A.length && A[son] < A[k * 2 + 2]) {
                son = k * 2 + 2;
            }
            if (A[son] < A[k]) {
                break;
            }
            [A[son], A[k]] = [A[k], A[son]];
            // 交换后再与新的儿子比较并交换，直至没有儿子。
            k = son;
        }
    }
}
exports.MaxHeap = MaxHeap;
const assert_1 = __importDefault(require("assert"));
{
    const minHeap = new MinHeap([
        2, 3, 1, 3, 4, 5, 1, 3, 6, 7, 8, 9, 54, 5, 7, 3, 2, 1, 2, 41, 5, 7,
    ]);
    assert_1.default.ok((0, __1.validHeap)(minHeap.data));
    minHeap.insert(0);
    minHeap.insert(99);
    assert_1.default.ok((0, __1.validHeap)(minHeap.data));
}
{
    const maxHeap = new MaxHeap([
        2, 3, 1, 3, 4, 5, 1, 3, 6, 7, 8, 9, 54, 5, 7, 3, 2, 1, 2, 41, 5, 7,
    ]);
    assert_1.default.ok((0, __1.validHeap)(maxHeap.data));
    maxHeap.insert(0);
    maxHeap.insert(99);
    assert_1.default.ok((0, __1.validHeap)(maxHeap.data));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoi5aCGLmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyLmlbDmja7nu5PmnoQv5aCGLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHNDQUFpQztBQUVqQyxNQUFlLElBQUk7SUFDakIsSUFBSSxHQUFhLEVBQUUsQ0FBQztJQUVwQixZQUFzQixHQUFhO1FBQ2pDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLFNBQVM7UUFDVCxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQ7O1NBRUs7SUFDTCxJQUFJLElBQUk7UUFDTixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzFCLENBQUM7SUFNRCxtQkFBbUI7UUFDakIsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNwQixrQkFBa0I7UUFDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hELElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3JCO1FBRUQsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRUQ7OztTQUdLO0lBQ0wsTUFBTSxDQUFDLEtBQWE7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7O1NBSUs7SUFDTCxNQUFNO1FBQ0osTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUs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Q0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7S0FDbkUsQ0FBQyxDQUFDO0lBQ0gsZ0JBQU0sQ0FBQyxFQUFFLENBQUMsSUFBQSxhQUFTLEVBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDbkMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25CLGdCQUFNLENBQUMsRUFBRSxDQUFDLElBQUEsYUFBUyxFQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0NBQ3BDO0FBQ0Q7SUFDRSxNQUFNLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQztRQUMxQixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO0tBQ25FLENBQUMsQ0FBQztJQUNILGdCQUFNLENBQUMsRUFBRSxDQUFDLElBQUEsYUFBUyxFQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ25DLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuQixnQkFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFBLGFBQVMsRUFBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUNwQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZhbGlkSGVhcCB9IGZyb20gXCIuL+WghuWMllwiO1xuXG5hYnN0cmFjdCBjbGFzcyBIZWFwIHtcbiAgZGF0YTogbnVtYmVyW10gPSBbXTtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYXJyOiBudW1iZXJbXSkge1xuICAgIHRoaXMuZGF0YSA9IFsuLi5hcnJdO1xuICAgIC8vIOWIneWni+WMliDloIbljJZcbiAgICB0aGlzLmhlYXBpZnlXaXRoU2lmdERvd24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDloIbnmoTlpKflsI9cbiAgICogKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gIH1cblxuICBhYnN0cmFjdCBzaWZ0RG93bihBOiBudW1iZXJbXSwgazogbnVtYmVyKTogdm9pZDtcblxuICBhYnN0cmFjdCBzaWZ0VXAoQTogbnVtYmVyW10sIGs6IG51bWJlcik6IHZvaWQ7XG5cbiAgaGVhcGlmeVdpdGhTaWZ0RG93bigpIHtcbiAgICBjb25zdCBBID0gdGhpcy5kYXRhO1xuICAgIC8vIOWIneWni+mAieaLqeacgOaOpei/keWPtuWtkOeahOS4gOS4queItue7k+eCuVxuICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKChBLmxlbmd0aCAtIDEpIC8gMik7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnNpZnREb3duKEEsIGkpO1xuICAgIH1cblxuICAgIHJldHVybiBBO1xuICB9XG5cbiAgLyoqXG4gICAqIOaPkuWFpVxuICAgKiDlnKjloIbnmoTlsL7pg6jmt7vliqDkuIDkuKrmlrDnmoTlhYPntKDvvIznhLblkI7kvb/nlKggc2hpZnRVcCDmnaXkv67lpI1cbiAgICogKi9cbiAgaW5zZXJ0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgdGhpcy5zaWZ0VXAodGhpcy5kYXRhLCB0aGlzLnNpemUgLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDnp7vpmaTlubbov5Tlm57mnIDlpKflgLzvvIjmnIDlpKfloIbvvInmiJbogIXmnIDlsI/lgLzvvIjmnIDlsI/loIbvvIlcbiAgICog5Li65LqG5bCG6L+Z5Liq6IqC54K55Yig6Zmk5ZCO55qE56m65L2N5aGr6KGl5LiK77yM6ZyA6KaB5bCG5pyA5ZCO5LiA5Liq5YWD57Sg56e75Yiw5qC56IqC54K555qE5L2N572u77yMXG4gICAqIOeEtuWQjuS9v+eUqCBzaGlmdERvd24g5pa55rOV5p2l5L+u5aSN5aCGXG4gICAqICovXG4gIHJlbW92ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRhdGEuc2hpZnQoKTtcbiAgICB0aGlzLmhlYXBpZnlXaXRoU2lmdERvd24oKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIOenu+mZpOW5tui/lOWbnuWghuacq+WwvueahOaVsOaNrlxuICAgKiAqL1xuICBwb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucG9wKCk7XG4gIH1cblxuICAvKipcbiAgICog56e76Zmk5aCG5Lit5Lu75oSP6IqC54K5XG4gICAqIOW9k+Wug+S4juWtkOiKgueCueavlOi+g+S9jee9ruS4jeaXtuaXoOW6j+aXtuS9v+eUqCBzaGlmdERvd24oKe+8jOWmguaenOS4jueItuiKgueCueavlOi+g+WPkeeOsOaXoOW6j+WImeS9v+eUqCBzaGlmdFVwKClcbiAgICogKi9cbiAgcmVtb3ZlQXRJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIOWwhuS4gOS4quabtOWwj+eahOWAvO+8iOacgOWwj+Wghu+8ieaIluiAheabtOWkp+eahOWAvO+8iOacgOWkp+Wghu+8iei1i+WAvOe7meS4gOS4quiKgueCuVxuICAgKlxuICAgKiAqL1xuICByZXBsYWNlKCkge31cbn1cblxuLyoqXG4gKiDmnIDlsI/loIYo5bCP6aG25aCGKVxuICogKi9cbmV4cG9ydCBjbGFzcyBNaW5IZWFwIGV4dGVuZHMgSGVhcCB7XG4gIGNvbnN0cnVjdG9yKGFycjogbnVtYmVyW10pIHtcbiAgICBzdXBlcihhcnIpO1xuICB9XG5cbiAgc2lmdFVwKEE6IG51bWJlcltdLCBrOiBudW1iZXIpOiB2b2lkIHtcbiAgICB3aGlsZSAoayAhPSAwKSB7XG4gICAgICAvLyDmib7liLDniLboioLngrlcbiAgICAgIGNvbnN0IGZhdGhlciA9IE1hdGguZmxvb3IoKGsgLSAxKSAvIDIpO1xuICAgICAgLy8g5aaC5p6c54i26IqC54K5ID4g5paw5Yqg5YWl55qE6IqC54K5IOespuWQiCDloIYg57uT5p2fIOivpei9rlxuICAgICAgaWYgKEFba10gPiBBW2ZhdGhlcl0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyDlj43kuYsg6YKj5LmIIOS6pOaNouS4pOS4quiKgueCuVxuICAgICAgW0Fba10sIEFbZmF0aGVyXV0gPSBbQVtmYXRoZXJdLCBBW2tdXTtcblxuICAgICAgLy8g546w5ZyoIOeOsOWcqOaWsOWKoOWFpeeahOiKgueCuSDnjrDlnKjlnKgg5Y6f5p2l55qE54i26IqC54K55LiKXG4gICAgICBrID0gZmF0aGVyO1xuICAgIH1cbiAgfVxuXG4gIHNpZnREb3duKEE6IG51bWJlcltdLCBrOiBudW1iZXIpOiB2b2lkIHtcbiAgICB3aGlsZSAoayAqIDIgKyAxIDwgQS5sZW5ndGgpIHtcbiAgICAgIGxldCBzb24gPSBrICogMiArIDE7XG4gICAgICAvLyDkuI7lhbbkuKTkuKrlhL/lrZDkuK3ovoPlsI/nmoTkuIDkuKrmr5TovoNcbiAgICAgIGlmIChrICogMiArIDIgPCBBLmxlbmd0aCAmJiBBW3Nvbl0gPiBBW2sgKiAyICsgMl0pIHtcbiAgICAgICAgc29uID0gayAqIDIgKyAyO1xuICAgICAgfVxuXG4gICAgICAvLyDoi6XlpKfkuo7lhL/lrZDvvIzliJnkuI7lhL/lrZDkuqTmjaLjgIJcbiAgICAgIGlmIChBW3Nvbl0gPiBBW2tdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgW0Fbc29uXSwgQVtrXV0gPSBbQVtrXSwgQVtzb25dXTtcbiAgICAgIC8vIOS6pOaNouWQjuWGjeS4juaWsOeahOWEv+WtkOavlOi+g+W5tuS6pOaNou+8jOebtOiHs+ayoeacieWEv+WtkOOAglxuICAgICAgayA9IHNvbjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiDmnIDlpKfloIYo5aSn6aG25aCGKVxuICogKi9cbmV4cG9ydCBjbGFzcyBNYXhIZWFwIGV4dGVuZHMgSGVhcCB7XG4gIGNvbnN0cnVjdG9yKGFycjogbnVtYmVyW10pIHtcbiAgICBzdXBlcihhcnIpO1xuICB9XG5cbiAgc2lmdFVwKEE6IG51bWJlcltdLCBrOiBudW1iZXIpOiB2b2lkIHtcbiAgICB3aGlsZSAoayAhPSAwKSB7XG4gICAgICAvLyDmib7liLDniLboioLngrlcbiAgICAgIGNvbnN0IGZhdGhlciA9IE1hdGguZmxvb3IoKGsgLSAxKSAvIDIpO1xuICAgICAgLy8g5aaC5p6c54i26IqC54K5ID4g5paw5Yqg5YWl55qE6IqC54K5IOespuWQiCDloIYg57uT5p2fIOivpei9rlxuICAgICAgaWYgKEFba10gPCBBW2ZhdGhlcl0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyDlj43kuYsg6YKj5LmIIOS6pOaNouS4pOS4quiKgueCuVxuICAgICAgW0Fba10sIEFbZmF0aGVyXV0gPSBbQVtmYXRoZXJdLCBBW2tdXTtcblxuICAgICAgLy8g546w5ZyoIOeOsOWcqOaWsOWKoOWFpeeahOiKgueCuSDnjrDlnKjlnKgg5Y6f5p2l55qE54i26IqC54K55LiKXG4gICAgICBrID0gZmF0aGVyO1xuICAgIH1cbiAgfVxuXG4gIHNpZnREb3duKEE6IG51bWJlcltdLCBrOiBudW1iZXIpOiB2b2lkIHtcbiAgICB3aGlsZSAoayAqIDIgKyAxIDwgQS5sZW5ndGgpIHtcbiAgICAgIGxldCBzb24gPSBrICogMiArIDE7XG4gICAgICBpZiAoayAqIDIgKyAyIDwgQS5sZW5ndGggJiYgQVtzb25dIDwgQVtrICogMiArIDJdKSB7XG4gICAgICAgIHNvbiA9IGsgKiAyICsgMjtcbiAgICAgIH1cblxuICAgICAgaWYgKEFbc29uXSA8IEFba10pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBbQVtzb25dLCBBW2tdXSA9IFtBW2tdLCBBW3Nvbl1dO1xuICAgICAgLy8g5Lqk5o2i5ZCO5YaN5LiO5paw55qE5YS/5a2Q5q+U6L6D5bm25Lqk5o2i77yM55u06Iez5rKh5pyJ5YS/5a2Q44CCXG4gICAgICBrID0gc29uO1xuICAgIH1cbiAgfVxufVxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbntcbiAgY29uc3QgbWluSGVhcCA9IG5ldyBNaW5IZWFwKFtcbiAgICAyLCAzLCAxLCAzLCA0LCA1LCAxLCAzLCA2LCA3LCA4LCA5LCA1NCwgNSwgNywgMywgMiwgMSwgMiwgNDEsIDUsIDcsXG4gIF0pO1xuICBhc3NlcnQub2sodmFsaWRIZWFwKG1pbkhlYXAuZGF0YSkpO1xuICBtaW5IZWFwLmluc2VydCgwKTtcbiAgbWluSGVhcC5pbnNlcnQoOTkpO1xuICBhc3NlcnQub2sodmFsaWRIZWFwKG1pbkhlYXAuZGF0YSkpO1xufVxue1xuICBjb25zdCBtYXhIZWFwID0gbmV3IE1heEhlYXAoW1xuICAgIDIsIDMsIDEsIDMsIDQsIDUsIDEsIDMsIDYsIDcsIDgsIDksIDU0LCA1LCA3LCAzLCAyLCAxLCAyLCA0MSwgNSwgNyxcbiAgXSk7XG4gIGFzc2VydC5vayh2YWxpZEhlYXAobWF4SGVhcC5kYXRhKSk7XG4gIG1heEhlYXAuaW5zZXJ0KDApO1xuICBtYXhIZWFwLmluc2VydCg5OSk7XG4gIGFzc2VydC5vayh2YWxpZEhlYXAobWF4SGVhcC5kYXRhKSk7XG59XG4iXX0=