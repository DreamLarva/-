/*
2552. 统计上升四元组
困难

提示
给你一个长度为 n 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。

如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的：

0 <= i < j < k < l < n 且
nums[i] < nums[k] < nums[j] < nums[l] 。


示例 1：

输入：nums = [1,3,2,4,5]
输出：2
解释：
- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] < nums[k] < nums[j] < nums[l] 。
- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] < nums[k] < nums[j] < nums[l] 。
没有其他的四元组，所以我们返回 2 。
示例 2：

输入：nums = [1,2,3,4]
输出：0
解释：只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] < nums[k] ，所以我们返回 0 。


提示：

4 <= nums.length <= 4000
1 <= nums[i] <= nums.length
nums 中所有数字 互不相同 ，nums 是一个排列。
* */
import _ from "lodash";

/**
 * 暴力解决 超时
 * */
function countQuadruplets1(nums: number[]): number {
  let result = 0;
  let m: [number, number?, number?, number?][] = [[nums[0]]];

  for (let i = 1; i < nums.length; i++) {
    const d: [number, number?, number?, number?][] = [];
    for (let j = 0; j < m.length; j++) {
      // 不加入到枚举中
      d.push(_.clone(m[j]));

      const c = m[j];
      if (c.length === 2 && c[0] < nums[i] && c[1]! > nums[i]) {
        c.splice(1, 0, nums[i]);
        d.push(c);
      } else if (c.length !== 2 && _.last(c)! < nums[i]) {
        // 可以加入到枚举中
        c.push(nums[i]);
        if (c.length === 4) {
          result++;
          // console.log(c);
        } else {
          d.push(c);
        }
      }
    }

    // 自己作为枚举的第一个

    d.push([nums[i]]);

    m = d;
  }

  return result;
}

/**
 * 官方解法
 * */
function countQuadruplets(nums: number[]): number {
  const n = nums.length;
  // 数组 pre，其中 pre[x] 表示 nums[0] 到 nums[j−1] 中小于 x 的元素个数
  const pre = new Array(n + 1).fill(0);
  let ans = 0;
  for (let j = 0; j < n; j++) {
    // 符合第四位的数量
    let suf = 0;
    for (let k = n - 1; k > j; k--) {
      if (nums[k] < nums[j]) {
        // 符合题目 中间2位 的条件
        // 则再符合4位的结果 所符有合 第1位的 乘 所有符合 第4位的 积
        ans += pre[nums[k]] * suf;
      } else {
        // 不符合
        // 则 现在的nums[k] 只能之后作为 nums[l]
        // 又因为现在 nums[k] > nums[j] 所以一定满足
        ++suf;
      }
    }

    // 不理解
    for (let x = nums[j] + 1; x <= n; ++x) {
      ++pre[x];
    }
  }

  return ans;
}

import assert from "assert";

// assert.strictEqual(countQuadruplets([1, 6, 3, 7, 2, 4, 5, 8]), 13);
assert.strictEqual(countQuadruplets([1, 3, 2, 4, 5]), 2);
// assert.strictEqual(countQuadruplets([1, 2, 3, 4]), 0);
// assert.strictEqual(
//   countQuadruplets([
//     178, 152, 109, 281, 196, 227, 272, 66, 224, 233, 51, 248, 39, 118, 111, 230,
//     250, 255, 114, 125, 221, 299, 205, 186, 181, 5, 61, 115, 228, 169, 101, 287,
//     269, 80, 57, 107, 143, 75, 198, 54, 53, 172, 40, 29, 96, 256, 83, 258, 74,
//     236, 241, 138, 261, 192, 128, 244, 234, 298, 214, 184, 168, 7, 164, 103, 3,
//     46, 249, 204, 288, 175, 85, 116, 130, 151, 275, 273, 217, 166, 124, 296,
//     136, 48, 158, 153, 291, 277, 268, 211, 30, 167, 20, 243, 276, 95, 202, 49,
//     246, 87, 9, 231, 50, 6, 56, 266, 24, 72, 11, 286, 189, 180, 37, 156, 94, 35,
//     280, 52, 117, 257, 159, 297, 160, 68, 112, 283, 64, 104, 220, 18, 38, 133,
//     1, 179, 193, 222, 219, 67, 289, 194, 16, 145, 173, 79, 163, 47, 290, 176,
//     191, 92, 42, 239, 139, 119, 253, 26, 123, 141, 264, 134, 23, 285, 32, 174,
//     206, 215, 146, 203, 254, 140, 28, 13, 161, 148, 267, 63, 88, 70, 182, 260,
//     2, 232, 19, 90, 33, 149, 27, 25, 144, 73, 293, 131, 135, 108, 201, 122, 185,
//     237, 235, 165, 69, 147, 59, 21, 245, 89, 45, 209, 102, 284, 120, 106, 110,
//     36, 78, 274, 97, 197, 41, 105, 91, 251, 98, 177, 34, 60, 82, 240, 216, 208,
//     84, 225, 187, 282, 207, 76, 55, 199, 71, 127, 292, 271, 129, 212, 100, 226,
//     195, 247, 223, 263, 10, 188, 142, 62, 113, 183, 242, 43, 137, 81, 229, 170,
//     8, 17, 14, 171, 238, 150, 15, 44, 121, 213, 190, 270, 154, 4, 93, 157, 65,
//     279, 262, 259, 278, 200, 265, 252, 77, 132, 12, 58, 162, 210, 22, 126, 99,
//     294, 295, 218, 31, 86, 155,
//   ]),
//   0
// );
