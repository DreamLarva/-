"use strict";
/*
给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
* */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryTree_1 = require("../util/BinaryTree");
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    // 递归
    const result = [];
    step(root);
    return result;
    function step(node) {
        if (node) {
            step(node.left);
            result.push(node.val);
            step(node.right);
        }
    }
};
var inorderTraversal_1 = function (root) {
    if (root == null)
        return [];
    // 迭代
    const result = [];
    const set = new Set();
    const stack = [];
    stack.push(root);
    while (stack.length) {
        const node = stack[stack.length - 1];
        if (node.left && !set.has(node.left)) {
            stack.push(node.left);
            continue;
        }
        result.push(node.val);
        set.add(node);
        stack.pop();
        if (node.right && !set.has(node.right)) {
            stack.push(node.right);
        }
    }
    return result;
};
const assert_1 = __importDefault(require("assert"));
assert_1.default.deepStrictEqual(inorderTraversal(BinaryTree_1.createBinaryTree([1, null, 2, 3])), [1, 3, 2]);
assert_1.default.deepStrictEqual(inorderTraversal_1(BinaryTree_1.createBinaryTree([1, null, 2, 3])), [1, 3, 2]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQu5LqM5Y+J5qCR55qE5Lit5bqP6YGN5Y6GLmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJsZWV0Y29kZS85NC7kuozlj4nmoJHnmoTkuK3luo/pgY3ljoYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7OztJQWNJOzs7OztBQUVKLG1EQUE4RDtBQUU5RDs7O0dBR0c7QUFDSCxJQUFJLGdCQUFnQixHQUFHLFVBQVUsSUFBc0I7SUFDbkQsS0FBSztJQUNMLE1BQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztJQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDWCxPQUFPLE1BQU0sQ0FBQztJQUVkLFNBQVMsSUFBSSxDQUFDLElBQTZCO1FBQ3ZDLElBQUksSUFBSSxFQUFFO1lBQ04sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3BCO0lBQ0wsQ0FBQztBQUNMLENBQUMsQ0FBQztBQUVGLElBQUksa0JBQWtCLEdBQUcsVUFBVSxJQUFzQjtJQUNyRCxJQUFJLElBQUksSUFBSSxJQUFJO1FBQUUsT0FBTyxFQUFFLENBQUM7SUFDNUIsS0FBSztJQUNMLE1BQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztJQUM1QixNQUFNLEdBQUcsR0FBMEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUM3QyxNQUFNLEtBQUssR0FBdUIsRUFBRSxDQUFDO0lBQ3JDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFakIsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ2pCLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2xDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3RCLFNBQVM7U0FDWjtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDZCxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFWixJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNwQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMxQjtLQUNKO0lBR0QsT0FBTyxNQUFNLENBQUM7QUFHbEIsQ0FBQyxDQUFDO0FBRUYsb0RBQTRCO0FBRTVCLGdCQUFNLENBQUMsZUFBZSxDQUNsQixnQkFBZ0IsQ0FBQyw2QkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDbkQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUNaLENBQUM7QUFDRixnQkFBTSxDQUFDLGVBQWUsQ0FDbEIsa0JBQWtCLENBQUMsNkJBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQ3JELENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FDWixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbue7meWumuS4gOS4quS6jOWPieagke+8jOi/lOWbnuWug+eahOS4reW6jyDpgY3ljobjgIJcblxu56S65L6LOlxuXG7ovpPlhaU6IFsxLG51bGwsMiwzXVxuICAgMVxuICAgIFxcXG4gICAgIDJcbiAgICAvXG4gICAzXG5cbui+k+WHujogWzEsMywyXVxu6L+b6Zi2OiDpgJLlvZLnrpfms5XlvojnroDljZXvvIzkvaDlj6/ku6XpgJrov4fov63ku6Pnrpfms5XlrozmiJDlkJfvvJ9cbiogKi9cblxuaW1wb3J0IHtUcmVlTm9kZSwgY3JlYXRlQmluYXJ5VHJlZX0gZnJvbSBcIi4uL3V0aWwvQmluYXJ5VHJlZVwiO1xuXG4vKipcbiAqIEBwYXJhbSB7VHJlZU5vZGV9IHJvb3RcbiAqIEByZXR1cm4ge251bWJlcltdfVxuICovXG52YXIgaW5vcmRlclRyYXZlcnNhbCA9IGZ1bmN0aW9uIChyb290OiBUcmVlTm9kZTxudW1iZXI+KSB7XG4gICAgLy8g6YCS5b2SXG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICAgIHN0ZXAocm9vdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIHN0ZXAobm9kZTogVHJlZU5vZGU8bnVtYmVyPiB8IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHN0ZXAobm9kZS5sZWZ0KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUudmFsKTtcbiAgICAgICAgICAgIHN0ZXAobm9kZS5yaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgaW5vcmRlclRyYXZlcnNhbF8xID0gZnVuY3Rpb24gKHJvb3Q6IFRyZWVOb2RlPG51bWJlcj4pIHtcbiAgICBpZiAocm9vdCA9PSBudWxsKSByZXR1cm4gW107XG4gICAgLy8g6L+t5LujXG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IHNldDogU2V0PFRyZWVOb2RlPG51bWJlcj4+ID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN0YWNrOiBUcmVlTm9kZTxudW1iZXI+W10gPSBbXTtcbiAgICBzdGFjay5wdXNoKHJvb3QpO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBub2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChub2RlLmxlZnQgJiYgIXNldC5oYXMobm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChub2RlLmxlZnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChub2RlLnZhbCk7XG4gICAgICAgIHNldC5hZGQobm9kZSk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChub2RlLnJpZ2h0ICYmICFzZXQuaGFzKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUucmlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG5cbn07XG5cbmltcG9ydCBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICAgIGlub3JkZXJUcmF2ZXJzYWwoY3JlYXRlQmluYXJ5VHJlZShbMSwgbnVsbCwgMiwgM10pKSxcbiAgICBbMSwgMywgMl0sXG4pO1xuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAgICBpbm9yZGVyVHJhdmVyc2FsXzEoY3JlYXRlQmluYXJ5VHJlZShbMSwgbnVsbCwgMiwgM10pKSxcbiAgICBbMSwgMywgMl0sXG4pO1xuIl19