"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
/*
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 m 和 n。

示例:

输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
说明:

A.length == n + m

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sorted-merge-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
* */
/**
 * @param {number[]} A
 * @param {number} m
 * @param {number[]} B
 * @param {number} n
 * @return {void} Do not return anything, modify A in-place instead.
 */
var merge = function (A, m, B, n) {
  // 从A数组末端 依照次序 放进两个数组的最大值
  let index = m + n - 1;
  let lastA = m - 1;
  let lastB = n - 1;
  while (index >= 0) {
    if (lastA < 0) {
      A.splice(0, lastB + 1, ...B.slice(0, lastB + 1));
      break;
    }
    if (lastB < 0) {
      break;
    }
    if (A[lastA] > B[lastB]) {
      A[index] = A[lastA];
      lastA--;
    } else {
      A[index] = B[lastB];
      lastB--;
    }
    index--;
  }
  return A;
};
const assert_1 = __importDefault(require("assert"));
assert_1.default.deepStrictEqual(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3), [
  1,
  2,
  2,
  3,
  5,
  6,
]);
assert_1.default.deepStrictEqual(merge([0], 0, [1], 1), [1]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoi6Z2i6K+V6aKYIDEwLjAxLiDlkIjlubbmjpLluo/nmoTmlbDnu4QuanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbImxlZXRjb2RlL+mdouivlemimCAxMC4wMS4g5ZCI5bm25o6S5bqP55qE5pWw57uELnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFtQkk7QUFDSjs7Ozs7O0dBTUc7QUFDSCxJQUFJLEtBQUssR0FBRyxVQUFVLENBQVcsRUFBRSxDQUFTLEVBQUUsQ0FBVyxFQUFFLENBQVM7SUFDbEUseUJBQXlCO0lBQ3pCLElBQUksS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLElBQUksS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsQixPQUFPLEtBQUssSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO1lBQ2IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pELE1BQU07U0FDUDtRQUVELElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtZQUNiLE1BQU07U0FDUDtRQUNELElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN2QixDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3BCLEtBQUssRUFBRSxDQUFDO1NBQ1Q7YUFBTTtZQUNMLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEIsS0FBSyxFQUFFLENBQUM7U0FDVDtRQUVELEtBQUssRUFBRSxDQUFDO0tBQ1Q7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQztBQUVGLG9EQUE0QjtBQUM1QixnQkFBTSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDakUsQ0FBQztJQUNELENBQUM7SUFDRCxDQUFDO0lBQ0QsQ0FBQztJQUNELENBQUM7SUFDRCxDQUFDO0NBQ0YsQ0FBQyxDQUFDO0FBQ0gsZ0JBQU0sQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbue7meWumuS4pOS4quaOkuW6j+WQjueahOaVsOe7hCBBIOWSjCBC77yM5YW25LitIEEg55qE5pyr56uv5pyJ6Laz5aSf55qE57yT5Yay56m66Ze05a6557qzIELjgIIg57yW5YaZ5LiA5Liq5pa55rOV77yM5bCGIEIg5ZCI5bm25YWlIEEg5bm25o6S5bqP44CCXG5cbuWIneWni+WMlsKgQSDlkowgQiDnmoTlhYPntKDmlbDph4/liIbliKvkuLrCoG0g5ZKMIG7jgIJcblxu56S65L6LOlxuXG7ovpPlhaU6XG5BID0gWzEsMiwzLDAsMCwwXSwgbSA9IDNcbkIgPSBbMiw1LDZdLCAgICAgICBuID0gM1xuXG7ovpPlh7o6wqBbMSwyLDIsMyw1LDZdXG7or7TmmI46XG5cbkEubGVuZ3RoID09IG4gKyBtXG5cbuadpea6kO+8muWKm+aJo++8iExlZXRDb2Rl77yJXG7pk77mjqXvvJpodHRwczovL2xlZXRjb2RlLWNuLmNvbS9wcm9ibGVtcy9zb3J0ZWQtbWVyZ2UtbGNjaVxu6JGX5L2c5p2D5b2S6aKG5omj572R57uc5omA5pyJ44CC5ZWG5Lia6L2s6L296K+36IGU57O75a6Y5pa55o6I5p2D77yM6Z2e5ZWG5Lia6L2s6L296K+35rOo5piO5Ye65aSE44CCXG4qICovXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IEFcbiAqIEBwYXJhbSB7bnVtYmVyfSBtXG4gKiBAcGFyYW0ge251bWJlcltdfSBCXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHJldHVybiB7dm9pZH0gRG8gbm90IHJldHVybiBhbnl0aGluZywgbW9kaWZ5IEEgaW4tcGxhY2UgaW5zdGVhZC5cbiAqL1xudmFyIG1lcmdlID0gZnVuY3Rpb24gKEE6IG51bWJlcltdLCBtOiBudW1iZXIsIEI6IG51bWJlcltdLCBuOiBudW1iZXIpIHtcbiAgLy8g5LuOQeaVsOe7hOacq+erryDkvp3nhafmrKHluo8g5pS+6L+b5Lik5Liq5pWw57uE55qE5pyA5aSn5YC8XG4gIGxldCBpbmRleCA9IG0gKyBuIC0gMTtcbiAgbGV0IGxhc3RBID0gbSAtIDE7XG4gIGxldCBsYXN0QiA9IG4gLSAxO1xuICB3aGlsZSAoaW5kZXggPj0gMCkge1xuICAgIGlmIChsYXN0QSA8IDApIHtcbiAgICAgIEEuc3BsaWNlKDAsIGxhc3RCICsgMSwgLi4uQi5zbGljZSgwLCBsYXN0QiArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChsYXN0QiA8IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoQVtsYXN0QV0gPiBCW2xhc3RCXSkge1xuICAgICAgQVtpbmRleF0gPSBBW2xhc3RBXTtcbiAgICAgIGxhc3RBLS07XG4gICAgfSBlbHNlIHtcbiAgICAgIEFbaW5kZXhdID0gQltsYXN0Ql07XG4gICAgICBsYXN0Qi0tO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbiAgcmV0dXJuIEE7XG59O1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwobWVyZ2UoWzEsIDIsIDMsIDAsIDAsIDBdLCAzLCBbMiwgNSwgNl0sIDMpLCBbXG4gIDEsXG4gIDIsXG4gIDIsXG4gIDMsXG4gIDUsXG4gIDYsXG5dKTtcbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwobWVyZ2UoWzBdLCAwLCBbMV0sIDEpLCBbMV0pO1xuIl19
