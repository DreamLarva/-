"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
/*
给定一个二叉树，返回它的 后序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [3,2,1]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
* */
const BinaryTree_1 = require("../util/BinaryTree");
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function (root) {
  /**
   * 正常使用递归
   * */
  const result = [];
  step(root);
  return result;
  function step(node) {
    if (node === null) return;
    step(node.left);
    step(node.right);
    result.push(node.val);
  }
};
function postorderTraversal_1(root) {
  /**
   * 使用迭代
   * 使用迭代版本的深度优先 妙啊
   * 后续遍历的 次序是 左子树 右子树 根节点
   * 现在深度优先的 次序是 根节点 右子树 左子树
   * 所以逆序输出 为需要的结果
   * */
  const result = [];
  const stack = [];
  stack.push(root);
  while (stack.length) {
    const node = stack.pop();
    result.unshift(node.val); // 逆序 输出值 所以都从头部推入
    if (node.left) stack.push(node.left);
    if (node.right) stack.push(node.right); // 由于使用的是栈 所以会优先查询 右子树的内容
  }
  return result;
}
const assert_1 = __importDefault(require("assert"));
assert_1.default.deepStrictEqual(
  postorderTraversal(BinaryTree_1.createBinaryTree([1, null, 2, 3])),
  [3, 2, 1]
);
assert_1.default.deepStrictEqual(
  postorderTraversal_1(BinaryTree_1.createBinaryTree([1, null, 2, 3])),
  [3, 2, 1]
);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ1LuS6jOWPieagkeeahOWQjuW6j+mBjeWOhi5qcyIsInNvdXJjZVJvb3QiOiIuLyIsInNvdXJjZXMiOlsibGVldGNvZGUvMTQ1LuS6jOWPieagkeeahOWQjuW6j+mBjeWOhi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQkk7QUFDSixtREFBOEQ7QUFFOUQ7OztHQUdHO0FBQ0gsSUFBSSxrQkFBa0IsR0FBRyxVQUFVLElBQXNCO0lBQ3JEOztTQUVLO0lBQ0wsTUFBTSxNQUFNLEdBQWEsRUFBRSxDQUFDO0lBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUVYLE9BQU8sTUFBTSxDQUFDO0lBRWQsU0FBUyxJQUFJLENBQUMsSUFBNkI7UUFDdkMsSUFBSSxJQUFJLEtBQUssSUFBSTtZQUFFLE9BQU87UUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLENBQUM7QUFFTCxDQUFDLENBQUM7QUFFRixTQUFTLG9CQUFvQixDQUFDLElBQXNCO0lBQ2hEOzs7Ozs7U0FNSztJQUNMLE1BQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztJQUM1QixNQUFNLEtBQUssR0FBdUIsRUFBRSxDQUFDO0lBQ3JDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakIsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ2pCLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUcsQ0FBQztRQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGtCQUFrQjtRQUM1QyxJQUFHLElBQUksQ0FBQyxJQUFJO1lBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkMsSUFBRyxJQUFJLENBQUMsS0FBSztZQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMseUJBQXlCO0tBQ2xFO0lBRUQsT0FBTyxNQUFNLENBQUE7QUFDakIsQ0FBQztBQUdELG9EQUE0QjtBQUU1QixnQkFBTSxDQUFDLGVBQWUsQ0FDbEIsa0JBQWtCLENBQUMsNkJBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQ3JELENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FDWixDQUFDO0FBQ0YsZ0JBQU0sQ0FBQyxlQUFlLENBQ2xCLG9CQUFvQixDQUFDLDZCQUFnQixDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUN2RCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG7nu5nlrprkuIDkuKrkuozlj4nmoJHvvIzov5Tlm57lroPnmoQg5ZCO5bqPwqDpgY3ljobjgIJcblxu56S65L6LOlxuXG7ovpPlhaU6IFsxLG51bGwsMiwzXVxuICAgMVxuICAgIFxcXG4gICAgIDJcbiAgICAvXG4gICAzXG5cbui+k+WHujogWzMsMiwxXVxu6L+b6Zi2OsKg6YCS5b2S566X5rOV5b6I566A5Y2V77yM5L2g5Y+v5Lul6YCa6L+H6L+t5Luj566X5rOV5a6M5oiQ5ZCX77yfXG5cbuadpea6kO+8muWKm+aJo++8iExlZXRDb2Rl77yJXG7pk77mjqXvvJpodHRwczovL2xlZXRjb2RlLWNuLmNvbS9wcm9ibGVtcy9iaW5hcnktdHJlZS1wb3N0b3JkZXItdHJhdmVyc2FsXG7okZfkvZzmnYPlvZLpoobmiaPnvZHnu5zmiYDmnInjgILllYbkuJrovazovb3or7fogZTns7vlrpjmlrnmjojmnYPvvIzpnZ7llYbkuJrovazovb3or7fms6jmmI7lh7rlpITjgIJcbiogKi9cbmltcG9ydCB7VHJlZU5vZGUsIGNyZWF0ZUJpbmFyeVRyZWV9IGZyb20gXCIuLi91dGlsL0JpbmFyeVRyZWVcIjtcblxuLyoqXG4gKiBAcGFyYW0ge1RyZWVOb2RlfSByb290XG4gKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAqL1xudmFyIHBvc3RvcmRlclRyYXZlcnNhbCA9IGZ1bmN0aW9uIChyb290OiBUcmVlTm9kZTxudW1iZXI+KSB7XG4gICAgLyoqXG4gICAgICog5q2j5bi45L2/55So6YCS5b2SXG4gICAgICogKi9cbiAgICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gICAgc3RlcChyb290KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBmdW5jdGlvbiBzdGVwKG5vZGU6IFRyZWVOb2RlPG51bWJlcj4gfCBudWxsKSB7XG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIHN0ZXAobm9kZS5sZWZ0KTtcbiAgICAgICAgc3RlcChub2RlLnJpZ2h0KTtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZS52YWwpO1xuICAgIH1cblxufTtcblxuZnVuY3Rpb24gcG9zdG9yZGVyVHJhdmVyc2FsXzEocm9vdDogVHJlZU5vZGU8bnVtYmVyPikge1xuICAgIC8qKlxuICAgICAqIOS9v+eUqOi/reS7o1xuICAgICAqIOS9v+eUqOi/reS7o+eJiOacrOeahOa3seW6puS8mOWFiCDlppnllYpcbiAgICAgKiDlkI7nu63pgY3ljobnmoQg5qyh5bqP5pivIOW3puWtkOagkSDlj7PlrZDmoJEg5qC56IqC54K5XG4gICAgICog546w5Zyo5rex5bqm5LyY5YWI55qEIOasoeW6j+aYryDmoLnoioLngrkg5Y+z5a2Q5qCRIOW3puWtkOagkVxuICAgICAqIOaJgOS7pemAhuW6j+i+k+WHuiDkuLrpnIDopoHnmoTnu5PmnpxcbiAgICAgKiAqL1xuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBzdGFjazogVHJlZU5vZGU8bnVtYmVyPltdID0gW107XG4gICAgc3RhY2sucHVzaChyb290KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGFjay5wb3AoKSE7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KG5vZGUudmFsKTsgLy8g6YCG5bqPIOi+k+WHuuWAvCDmiYDku6Xpg73ku47lpLTpg6jmjqjlhaVcbiAgICAgICAgaWYobm9kZS5sZWZ0KXN0YWNrLnB1c2gobm9kZS5sZWZ0KTtcbiAgICAgICAgaWYobm9kZS5yaWdodClzdGFjay5wdXNoKG5vZGUucmlnaHQpOyAvLyDnlLHkuo7kvb/nlKjnmoTmmK/moIgg5omA5Lul5Lya5LyY5YWI5p+l6K+iIOWPs+WtkOagkeeahOWGheWuuVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbn1cblxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAgICBwb3N0b3JkZXJUcmF2ZXJzYWwoY3JlYXRlQmluYXJ5VHJlZShbMSwgbnVsbCwgMiwgM10pKSxcbiAgICBbMywgMiwgMV0sXG4pO1xuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAgICBwb3N0b3JkZXJUcmF2ZXJzYWxfMShjcmVhdGVCaW5hcnlUcmVlKFsxLCBudWxsLCAyLCAzXSkpLFxuICAgIFszLCAyLCAxXSxcbik7XG4iXX0=
