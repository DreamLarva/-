"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
* */
const lodash_1 = __importDefault(require("lodash"));
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function (nums, k) {
    /**
     * 方法一 不断的堆化(求第k大的值 用**最小堆**) 并且保持 一定的长度(k)
     * 慢的一b
     * */
    const minHeap = [];
    for (let i = 0; i < nums.length; i++) {
        // 优化 如果小于顶部 就直接 过
        if (minHeap.length === k && nums[i] < minHeap[0])
            continue;
        minHeap.push(nums[i]);
        heapifyWithSiftDown(minHeap);
        if (minHeap.length > k) {
            minHeap.shift();
        }
    }
    // 还必须再堆化一次 使最小值 在第一个
    heapifyWithSiftDown(minHeap);
    return minHeap[0];
    function heapifyWithSiftDown(A) {
        // 初始选择最接近叶子的一个父结点
        for (let i = Math.floor((A.length - 1) / 2); i >= 0; i--) {
            siftDown(A, i);
        }
        return A;
    }
    function siftDown(A, k) {
        // 此处是 最小堆
        while (k * 2 + 1 < A.length) {
            let son = k * 2 + 1;
            // 与其两个儿子中较小的一个比较
            if (k * 2 + 2 < A.length && A[son] > A[k * 2 + 2]) {
                son = k * 2 + 2;
            }
            // 若大于儿子，则与儿子交换。
            if (A[son] > A[k]) {
                break;
            }
            [A[son], A[k]] = [A[k], A[son]];
            // 交换后再与新的儿子比较并交换，直至没有儿子。
            k = son;
        }
    }
};
var findKthLargest_1 = function (nums, k) {
    /**
     * 方法二 快速选择法(Hoare 选择法)
     * */
    const size = nums.length;
    return quickSelect(0, size - 1, size - k);
    function partition(left, right, pivot_index) {
        let pivot = nums[pivot_index];
        // 现将 枢轴 换到末尾 方便 操作
        [nums[pivot_index], nums[right]] = [nums[right], nums[pivot_index]];
        // 存储 枢轴新的位置
        let store_index = left;
        // 枢轴的值 放到左边
        for (let i = left; i <= right; i++) {
            if (nums[i] < pivot) {
                [nums[store_index], nums[i]] = [nums[i], nums[store_index]];
                store_index++;
            }
        }
        // 将在最末尾的枢轴的值 放到新的位置
        [nums[store_index], nums[right]] = [nums[right], nums[store_index]];
        return store_index;
    }
    function quickSelect(left, right, k_smallest) {
        // 如果 左右为 同一个值 那么说明 只有一个值 不需要再选择了
        if (left === right) {
            return nums[left];
        }
        // 随机 用一个值作为 index 作为枢轴 并且返回 枢轴的 index
        let pivot_index = partition(left, right, lodash_1.default.random(left, right - 1)); // lodash 的 random 是含头 含尾的
        if (k_smallest === pivot_index)
            return nums[k_smallest];
        // 如果 枢轴的 index 小于 k_smallest 说明 值 还在有枢轴的右侧
        else if (k_smallest < pivot_index)
            return quickSelect(left, pivot_index - 1, k_smallest);
        // 如果 枢轴的 index 大于 k_smallest 说明 值 还在有枢轴的左侧
        return quickSelect(pivot_index + 1, right, k_smallest);
    }
};
const assert_1 = __importDefault(require("assert"));
assert_1.default.strictEqual(findKthLargest([3, 2, 1, 5, 6, 4], 2), 5);
assert_1.default.strictEqual(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4), 4);
assert_1.default.strictEqual(findKthLargest_1([3, 2, 1, 5, 6, 4], 2), 5);
assert_1.default.strictEqual(findKthLargest_1([3, 2, 3, 1, 2, 4, 5, 5, 6], 4), 4);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE1LuaVsOe7hOS4reeahOesrEvkuKrmnIDlpKflhYPntKAuanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbImxlZXRjb2RlLzIxNS7mlbDnu4TkuK3nmoTnrKxL5Liq5pyA5aSn5YWD57SgLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWtCSTtBQUNKLG9EQUF1QjtBQUV2Qjs7OztHQUlHO0FBQ0gsSUFBSSxjQUFjLEdBQUcsVUFBVSxJQUFjLEVBQUUsQ0FBUztJQUN0RDs7O1NBR0s7SUFDTCxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7SUFDbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDcEMsa0JBQWtCO1FBQ2xCLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFBRSxTQUFTO1FBQzNELE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsbUJBQW1CLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0IsSUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN0QixPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDakI7S0FDRjtJQUNELHFCQUFxQjtJQUNyQixtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QixPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVsQixTQUFTLG1CQUFtQixDQUFDLENBQVc7UUFDdEMsa0JBQWtCO1FBQ2xCLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJ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QUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG7lnKjmnKrmjpLluo/nmoTmlbDnu4TkuK3mib7liLDnrKwgayDkuKrmnIDlpKfnmoTlhYPntKDjgILor7fms6jmhI/vvIzkvaDpnIDopoHmib7nmoTmmK/mlbDnu4TmjpLluo/lkI7nmoTnrKwgayDkuKrmnIDlpKfnmoTlhYPntKDvvIzogIzkuI3mmK/nrKwgayDkuKrkuI3lkIznmoTlhYPntKDjgIJcblxu56S65L6LIDE6XG5cbui+k+WFpTogWzMsMiwxLDUsNiw0XSDlkowgayA9IDJcbui+k+WHujogNVxu56S65L6LwqAyOlxuXG7ovpPlhaU6IFszLDIsMywxLDIsNCw1LDUsNl0g5ZKMIGsgPSA0XG7ovpPlh7o6IDRcbuivtOaYjjpcblxu5L2g5Y+v5Lul5YGH6K6+IGsg5oC75piv5pyJ5pWI55qE77yM5LiUIDEg4omkIGsg4omkIOaVsOe7hOeahOmVv+W6puOAglxuXG7mnaXmupDvvJrlipvmiaPvvIhMZWV0Q29kZe+8iVxu6ZO+5o6l77yaaHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLWxhcmdlc3QtZWxlbWVudC1pbi1hbi1hcnJheVxu6JGX5L2c5p2D5b2S6aKG5omj572R57uc5omA5pyJ44CC5ZWG5Lia6L2s6L296K+36IGU57O75a6Y5pa55o6I5p2D77yM6Z2e5ZWG5Lia6L2s6L296K+35rOo5piO5Ye65aSE44CCXG4qICovXG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbnVtc1xuICogQHBhcmFtIHtudW1iZXJ9IGtcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xudmFyIGZpbmRLdGhMYXJnZXN0ID0gZnVuY3Rpb24gKG51bXM6IG51bWJlcltdLCBrOiBudW1iZXIpIHtcbiAgLyoqXG4gICAqIOaWueazleS4gCDkuI3mlq3nmoTloIbljJYo5rGC56ysa+Wkp+eahOWAvCDnlKgqKuacgOWwj+WghioqKSDlubbkuJTkv53mjIEg5LiA5a6a55qE6ZW/5bqmKGspXG4gICAqIOaFoueahOS4gGJcbiAgICogKi9cbiAgY29uc3QgbWluSGVhcCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyDkvJjljJYg5aaC5p6c5bCP5LqO6aG26YOoIOWwseebtOaOpSDov4dcbiAgICBpZiAobWluSGVhcC5sZW5ndGggPT09IGsgJiYgbnVtc1tpXSA8IG1pbkhlYXBbMF0pIGNvbnRpbnVlO1xuICAgIG1pbkhlYXAucHVzaChudW1zW2ldKTtcbiAgICBoZWFwaWZ5V2l0aFNpZnREb3duKG1pbkhlYXApO1xuICAgIGlmIChtaW5IZWFwLmxlbmd0aCA+IGspIHtcbiAgICAgIG1pbkhlYXAuc2hpZnQoKTtcbiAgICB9XG4gIH1cbiAgLy8g6L+Y5b+F6aG75YaN5aCG5YyW5LiA5qyhIOS9v+acgOWwj+WAvCDlnKjnrKzkuIDkuKpcbiAgaGVhcGlmeVdpdGhTaWZ0RG93bihtaW5IZWFwKTtcbiAgcmV0dXJuIG1pbkhlYXBbMF07XG5cbiAgZnVuY3Rpb24gaGVhcGlmeVdpdGhTaWZ0RG93bihBOiBudW1iZXJbXSkge1xuICAgIC8vIOWIneWni+mAieaLqeacgOaOpei/keWPtuWtkOeahOS4gOS4queItue7k+eCuVxuICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKChBLmxlbmd0aCAtIDEpIC8gMik7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzaWZ0RG93bihBLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZnREb3duKEE6IG51bWJlcltdLCBrOiBudW1iZXIpIHtcbiAgICAvLyDmraTlpITmmK8g5pyA5bCP5aCGXG4gICAgd2hpbGUgKGsgKiAyICsgMSA8IEEubGVuZ3RoKSB7XG4gICAgICBsZXQgc29uID0gayAqIDIgKyAxO1xuICAgICAgLy8g5LiO5YW25Lik5Liq5YS/5a2Q5Lit6L6D5bCP55qE5LiA5Liq5q+U6L6DXG4gICAgICBpZiAoayAqIDIgKyAyIDwgQS5sZW5ndGggJiYgQVtzb25dID4gQVtrICogMiArIDJdKSB7XG4gICAgICAgIHNvbiA9IGsgKiAyICsgMjtcbiAgICAgIH1cblxuICAgICAgLy8g6Iul5aSn5LqO5YS/5a2Q77yM5YiZ5LiO5YS/5a2Q5Lqk5o2i44CCXG4gICAgICBpZiAoQVtzb25dID4gQVtrXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFtBW3Nvbl0sIEFba11dID0gW0Fba10sIEFbc29uXV07XG4gICAgICAvLyDkuqTmjaLlkI7lho3kuI7mlrDnmoTlhL/lrZDmr5TovoPlubbkuqTmjaLvvIznm7Toh7PmsqHmnInlhL/lrZDjgIJcbiAgICAgIGsgPSBzb247XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmluZEt0aExhcmdlc3RfMSA9IGZ1bmN0aW9uIChudW1zOiBudW1iZXJbXSwgazogbnVtYmVyKSB7XG4gIC8qKlxuICAgKiDmlrnms5Xkuowg5b+r6YCf6YCJ5oup5rOVKEhvYXJlIOmAieaLqeazlSlcbiAgICogKi9cbiAgY29uc3Qgc2l6ZSA9IG51bXMubGVuZ3RoO1xuICByZXR1cm4gcXVpY2tTZWxlY3QoMCwgc2l6ZSAtIDEsIHNpemUgLSBrKTtcblxuICBmdW5jdGlvbiBwYXJ0aXRpb24obGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBwaXZvdF9pbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHBpdm90ID0gbnVtc1twaXZvdF9pbmRleF07XG4gICAgLy8g546w5bCGIOaeoui9tCDmjaLliLDmnKvlsL4g5pa55L6/IOaTjeS9nFxuICAgIFtudW1zW3Bpdm90X2luZGV4XSwgbnVtc1tyaWdodF1dID0gW251bXNbcmlnaHRdLCBudW1zW3Bpdm90X2luZGV4XV07XG4gICAgLy8g5a2Y5YKoIOaeoui9tOaWsOeahOS9jee9rlxuICAgIGxldCBzdG9yZV9pbmRleCA9IGxlZnQ7XG5cbiAgICAvLyDmnqLovbTnmoTlgLwg5pS+5Yiw5bem6L65XG4gICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgaWYgKG51bXNbaV0gPCBwaXZvdCkge1xuICAgICAgICBbbnVtc1tzdG9yZV9pbmRleF0sIG51bXNbaV1dID0gW251bXNbaV0sIG51bXNbc3RvcmVfaW5kZXhdXTtcbiAgICAgICAgc3RvcmVfaW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8g5bCG5Zyo5pyA5pyr5bC+55qE5p6i6L2055qE5YC8IOaUvuWIsOaWsOeahOS9jee9rlxuICAgIFtudW1zW3N0b3JlX2luZGV4XSwgbnVtc1tyaWdodF1dID0gW251bXNbcmlnaHRdLCBudW1zW3N0b3JlX2luZGV4XV07XG4gICAgcmV0dXJuIHN0b3JlX2luZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gcXVpY2tTZWxlY3QoXG4gICAgbGVmdDogbnVtYmVyLFxuICAgIHJpZ2h0OiBudW1iZXIsXG4gICAga19zbWFsbGVzdDogbnVtYmVyXG4gICk6IG51bWJlciB7XG4gICAgLy8g5aaC5p6cIOW3puWPs+S4uiDlkIzkuIDkuKrlgLwg6YKj5LmI6K+05piOIOWPquacieS4gOS4quWAvCDkuI3pnIDopoHlho3pgInmi6nkuoZcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgIHJldHVybiBudW1zW2xlZnRdO1xuICAgIH1cbiAgICAvLyDpmo/mnLog55So5LiA5Liq5YC85L2c5Li6IGluZGV4IOS9nOS4uuaeoui9tCDlubbkuJTov5Tlm54g5p6i6L2055qEIGluZGV4XG4gICAgbGV0IHBpdm90X2luZGV4ID0gcGFydGl0aW9uKGxlZnQsIHJpZ2h0LCBfLnJhbmRvbShsZWZ0LCByaWdodCAtIDEpKTsgLy8gbG9kYXNoIOeahCByYW5kb20g5piv5ZCr5aS0IOWQq+WwvueahFxuXG4gICAgaWYgKGtfc21hbGxlc3QgPT09IHBpdm90X2luZGV4KSByZXR1cm4gbnVtc1trX3NtYWxsZXN0XTtcbiAgICAvLyDlpoLmnpwg5p6i6L2055qEIGluZGV4IOWwj+S6jiBrX3NtYWxsZXN0IOivtOaYjiDlgLwg6L+Y5Zyo5pyJ5p6i6L2055qE5Y+z5L6nXG4gICAgZWxzZSBpZiAoa19zbWFsbGVzdCA8IHBpdm90X2luZGV4KVxuICAgICAgcmV0dXJuIHF1aWNrU2VsZWN0KGxlZnQsIHBpdm90X2luZGV4IC0gMSwga19zbWFsbGVzdCk7XG4gICAgLy8g5aaC5p6cIOaeoui9tOeahCBpbmRleCDlpKfkuo4ga19zbWFsbGVzdCDor7TmmI4g5YC8IOi/mOWcqOacieaeoui9tOeahOW3puS+p1xuICAgIHJldHVybiBxdWlja1NlbGVjdChwaXZvdF9pbmRleCArIDEsIHJpZ2h0LCBrX3NtYWxsZXN0KTtcbiAgfVxufTtcblxuaW1wb3J0IGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XG5cbmFzc2VydC5zdHJpY3RFcXVhbChmaW5kS3RoTGFyZ2VzdChbMywgMiwgMSwgNSwgNiwgNF0sIDIpLCA1KTtcbmFzc2VydC5zdHJpY3RFcXVhbChmaW5kS3RoTGFyZ2VzdChbMywgMiwgMywgMSwgMiwgNCwgNSwgNSwgNl0sIDQpLCA0KTtcbmFzc2VydC5zdHJpY3RFcXVhbChmaW5kS3RoTGFyZ2VzdF8xKFszLCAyLCAxLCA1LCA2LCA0XSwgMiksIDUpO1xuYXNzZXJ0LnN0cmljdEVxdWFsKGZpbmRLdGhMYXJnZXN0XzEoWzMsIDIsIDMsIDEsIDIsIDQsIDUsIDUsIDZdLCA0KSwgNCk7XG4iXX0=